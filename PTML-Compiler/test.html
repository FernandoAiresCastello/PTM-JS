<!DOCTYPE html>
<html>
<head>
    <title>PTM</title>
    <meta charset='UTF-8'>
    <script>

    document.addEventListener('DOMContentLoaded', Init, false);
    document.addEventListener('DOMContentLoaded', Main, false);

/*=============================================================================

        PTM - Programmable Tile Machine
        2021 developed by Fernando Aires Castello
        https://github.com/FernandoAiresCastello
    
=============================================================================*/

let Cmd = {};
let PrgLines = [];
let PrgLabels = {};
let ExecPtr = 0;
let TileWidth = 8;
let TileHeight = 8;
let Canvas = null;
let ScreenWidth = 160;
let ScreenHeight = 144;
let ScreenZoom = 3;
let CanvasWidth = ScreenZoom * ScreenWidth;
let CanvasHeight = ScreenZoom * ScreenHeight;
let Cols = ScreenWidth / TileWidth;
let Rows = ScreenHeight / TileHeight;
let GridTileWidth = CanvasWidth / Cols;
let GridTileHeight = CanvasHeight / Rows;
let PixelWidth = GridTileWidth / TileWidth;
let PixelHeight = GridTileHeight / TileHeight;
let PixelBuffer = [];
let Running = false;
let CycleHandle = null;
let Cycles = 0;
let Branching = false;
let DebugPanel = null;
let PauseCycles = 0;

function InitCommands() {

    Cmd['NOP'] = (p) => {
    }
    Cmd['LOG'] = (p) => {
        Log(p[0]);
    }
    Cmd['HALT'] = (p) => {
        Running = false;
        Log("Machine halted");
    }
    Cmd['PAUSE'] = (p) => {
        PauseCycles = ToNumber(p[0]);
    }
    Cmd['CLS'] = (p) => {
        FillPixelBuffer(p[0]);
    }
    Cmd['PSET'] = (p) => {
        PutPixel(ToNumber(p[0]), ToNumber(p[1]), p[2]);
    }
    Cmd['DRAW'] = (p) => {
        DrawPixelBuffer();
    }
    Cmd['GOTO'] = (p) => {
        Branch(p[0]);
    }
}

function Branch(idLabel) {
    const label = PrgLabels[idLabel];
    if (label === null || label === undefined) {
        Abort('Undefined label: ' + idLabel);
        return;
    }
    ExecPtr = label;
    Branching = true;
}

function ToNumber(str) {
    return Number.parseInt(str);
}

function InitGraphics() {
    const canvasElement = document.getElementById('canvas');
    canvasElement.width = CanvasWidth;
    canvasElement.height = CanvasHeight;
    Canvas = canvasElement.getContext('2d');
    Canvas.imageSmoothingEnabled = false;
    Canvas.strokeStyle = '';
    ClearCanvas('#000');
    FillPixelBuffer('#000');
    DrawPixelBuffer();
}

function ClearCanvas(rgb) {
    Canvas.fillStyle = rgb;
    Canvas.fillRect(0, 0, CanvasWidth, CanvasHeight);
}

function FillPixelBuffer(rgb) {
    for (let i = 0; i < ScreenWidth * ScreenHeight; i++)
        PixelBuffer[i] = rgb;
}

function PutPixel(x, y, rgb) {
    PixelBuffer[y * ScreenWidth + x] = rgb;
}

function GetPixel(x, y) {
    return PixelBuffer[y * ScreenWidth + x];
}

function DrawPixelBuffer() {
    let x = 0;
    let y = 0;

    for (let i = 0; i < PixelBuffer.length; i++) {
        Canvas.fillStyle = PixelBuffer[i];
        Canvas.fillRect(x, y, PixelWidth, PixelHeight);
        x += PixelWidth;
        if (x >= CanvasWidth) {
            x = 0;
            y += PixelHeight;
        }
    }
}

function Log(text) {
    console.log(text);
}

function AddPrgLabel(name, prgLineNr) {
    PrgLabels[name] = prgLineNr;
}

function AddPrgLine(srcLineNr, cmd, params) {
    PrgLines.push({
        SrcLineNr: srcLineNr,
        Command: cmd,
        Params: params
    });
}

function SetDebugMsg(msg) {
    DebugPanel.innerHTML = msg;
}

function Abort(msg) {
    Running = false;
    console.error(msg);
}

function StartCycleLoop() {
    Running = true;
    Log("Machine started");
    Cycle();
}

function Cycle() {

    SetDebugMsg('Cycles: ' + Cycles);

    if (Running) {
        if (PauseCycles > 0) {
            PauseCycles--;
            CycleHandle = window.requestAnimationFrame(() => Cycle());
            return;
        }
        else {
            ExecuteLine(PrgLines[ExecPtr]);
        }
        Cycles++;
    }
    if (!Running) {
        window.cancelAnimationFrame(CycleHandle);
        return;
    }

    if (Branching)
        Branching = false;
    else
        ExecPtr++;

    if (ExecPtr >= PrgLines.length) {
        Running = false;
        Abort('Execution pointer past end of program');
    }

    CycleHandle = window.requestAnimationFrame(() => Cycle());
}

function ExecuteLine(line) {
    const fn = Cmd[line.Command];
    if (fn) {
        fn(line.Params);
    }
    else {
        Abort(`Invalid command at line ${line.SrcLineNr}: ${line.Command}`);
    }
}

function Init() {
    InitCommands();
    InitGraphics();
    DebugPanel = document.getElementById('debug-panel');
}

function Main() {
	AddPrgLabel('Main', PrgLines.length);
	AddPrgLine(2, 'LOG', ['Hello World!']);
	AddPrgLabel('Loop', PrgLines.length);
	AddPrgLine(5, 'CLS', ['#f00']);
	AddPrgLine(6, 'DRAW', []);
	AddPrgLine(7, 'CLS', ['#0f0']);
	AddPrgLine(8, 'DRAW', []);
	AddPrgLine(9, 'CLS', ['#00f']);
	AddPrgLine(10, 'DRAW', []);
	AddPrgLine(11, 'GOTO', ['Loop']);

    StartCycleLoop();
}

    </script>
    <style>
        body {
            background: #000;
            color: #fff;
            font-family: Consolas, monospace;
            font-size: 12px;
        }
        table {
            border: 0;
            border-collapse: collapse;
            padding: 0;
            margin: auto;
        }
        canvas {
            border: 1px solid #333;
        }
        #debug-panel {
            border: 0;
            padding: 0 5px;
        }
    </style>
</head>
<body>
    <table>
        <tr><td><canvas id='canvas' width='0' height='0'></canvas></td></tr>
        <tr><td><div id='debug-panel'></div></td></tr>
    </table>
</body>
</html>
